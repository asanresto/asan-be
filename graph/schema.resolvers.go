package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"asan/graph/model"
	"asan/graph/resolver"
	"context"
	"errors"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.NewProduct) (*model.Product, error) {
	return resolver.CreateProduct(input)
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.NewOrder) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: CreateOrder - createOrder"))
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthResponse, error) {
	return resolver.LogIn(ctx, email, password)
}

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input model.SignUpPayload) (bool, error) {
	return resolver.SignUp(input)
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (bool, error) {
	return resolver.HandleForgotPassword(ctx, email)
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, resetPasswordToken string, newPassword string, confirmPassword string) (bool, error) {
	panic(fmt.Errorf("not implemented: ResetPassword - resetPassword"))
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken *string) (*model.AuthResponse, error) {
	return resolver.RefreshToken(ctx, refreshToken)
}

// LogOut is the resolver for the logOut field.
func (r *mutationResolver) LogOut(ctx context.Context, refreshToken *string) (bool, error) {
	return resolver.LogOut(ctx, refreshToken)
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, avatar *graphql.Upload, name *string) (bool, error) {
	return resolver.UpdateAccount(ctx, avatar, name)
}

// SendChatMessage is the resolver for the sendChatMessage field.
func (r *mutationResolver) SendChatMessage(ctx context.Context, message string, roomID string) (bool, error) {
	return resolver.SendChatMessage(ctx, message, roomID)
	// db.GetPostgresInstance().Query(context.Background(), "select user_id from user_chat_rooms where room_id = $1;", roomID)
	// coll := db.GetMongoInstance().Database("asan").Collection("chat")
	// msg := model.SendMessagePayload{Content: message, RoomID: roomID, CreatedAt: time.Now()}
	// _, err := coll.InsertOne(context.TODO(), msg)
	// if err != nil {
	// 	return false, err
	// }
	// if ch := channels[msg.RoomID]; ch != nil {
	// 	ch <- &model.Message{Content: message}
	// }
	// if channel, ok := r.Channels.Load("1"); ok {
	// 	channel.(chan *model.Message) <- &model.Message{Content: message, SenderID: &userId}
	// }
	// return true, nil
}

// CreateChatRoom is the resolver for the createChatRoom field.
func (r *mutationResolver) CreateChatRoom(ctx context.Context, userIds []string) (bool, error) {
	return resolver.CreateChatRoom(ctx, userIds)
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, currentPassword string, newPassword string, confirmPassword string) (bool, error) {
	// return resolver.ChangePassword(ctx, currentPassword, newPassword, confirmPassword)
	return false, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, filter *model.ProductFiltersInput, search *string, page *int, limit *int, sort *string) (*model.PaginatedProducts, error) {
	return resolver.Products(ctx, filter, search, page, limit, sort)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	return resolver.HandleUsers(ctx)
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	return resolver.Me(ctx)
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context, roomID string) ([]*model.Message, error) {
	panic(fmt.Errorf("not implemented: Messages - messages"))
}

// ChatRooms is the resolver for the chatRooms field.
func (r *queryResolver) ChatRooms(ctx context.Context) ([]*model.ChatRoom, error) {
	panic(fmt.Errorf("not implemented: ChatRooms - chatRooms"))
}

// Message is the resolver for the message field.
func (r *subscriptionResolver) Message(ctx context.Context) (<-chan *model.Message, error) {
	userId := ctx.Value("userId").(string)
	if userId == "" {
		return nil, errors.New("unauthorized")
	}
	// var isInThisRoom bool
	// if err := db.GetPostgresInstance().QueryRow(context.Background(), "select exists (select 1 from user_chat_rooms where id=$1 and user_id=$2)", roomID, userId).Scan(&isInThisRoom); err != nil {
	// 	return nil, errors.New("not in this room")
	// }
	// if !isInThisRoom {
	// 	return nil, errors.New("not in this room")
	// }
	// ch := make(chan *model.Message, 1)
	// channels[userId] = ch
	go func() {
		// defer close(ch)
		// r.Channels.Delete(userId)
		// for {
		// 	select {
		// 	case <-ch:
		// 		fmt.Println("123123123")
		// 		// Our message went through
		// 	case <-ctx.Done():
		// 		// Exit on cancellation
		// 		return
		// 	}
		// }
		// Wait for context cancellation. Subscription closes.
		<-ctx.Done()
		r.Channels.Delete(userId)
	}()
	return r.CreateChannel(userId), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
